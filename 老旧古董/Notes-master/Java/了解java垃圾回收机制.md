### 辣鸡回收是啥子幺
**辣鸡回收机制**（Garbage Collection，GC），这个不陌生吧，只要学到对象都应该或多或少的了解一些吧。辣鸡回收就是把内存中的垃圾（无用的数据...）给释放，而垃圾回收这个事情当然不要需要我们高贵的java程序员自己去解决喽，毕竟有老婆的男人（有老婆不一定是男的还可能是百合）怎么可能还会用自己的**恶魔右手妹妹**来解决，当然是用“我们”的**老婆jvm**来搞定嘛。  （这一点c/c++**程序员**做不到毕竟他们**没老婆**嘛，理解理解）  
### 老婆慧眼识辣鸡
**问：老婆这么知道这内存中那些是辣鸡那些不是呢？**

老婆：“问得好，要想辨别他是不是辣鸡当然要试试...额不是我的意思是问问这个疑似垃圾的对象有木有被“使用”，如果没有辣么这个对象就是辣鸡。”
比如：
```java
public class 2b{
         void k()}{
          sb sl = new sb();
            sl=null;     //sl赋值为null，意味着sl指向sb对象不可被“引用”
    }
}
class sb{
}
```  
>这个算法的实现是，给对象中添加一个引用计数器，每当一个地方引用这个对象时，计数器值+1；当引用失效时，计数器值-1。  
>任何时刻计数值为0的对象就是不可能再被使用的。 
> 这种算法使用场景很多，但是，Java中却没有使用这种算法(python就用的这个算法（＾ω＾）），因为这种算法很难解决对象之间相互引用的情况。
  
老婆扶头叹气道：“哎，虽是如此但是依然有一些小人搞基让我无从下手，但是魔高一尺道高一丈，我还有可以搞定他们的。”
```
public class 2b{
         void k()}{
          sb sl = new sb();
           sb s2 =new sb();
           sl=s2;
            s2=sl;
    }
}
class sb{
}
```
>由于它们互相引用对方，导致它们的引用计数都不为0，那么垃圾收集器就永远不会回收它们。

>　　为了解决这个问题，在Java中采取了 可达性分析法。该方法的基本思想是通过一系列的“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的，不过要注意的是被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。

程序员：“奥？既然那夫人为何还不搞定此二小人”  
老婆：“哎，我也想但我tm的没空间（内存）了，垃圾回收的启动按键找不到了，嘤嘤嘤~”  
程序员 ：“老婆莫扰，我有备用按键`System.gc`”  

>当你的垃圾回收机制一直没有运行的话，那是jvm闹脾气了，因为jvm在内存空间不足的情况下是可能不会运行垃圾回收的，所以你需要一些小手段来调节一下这个娇妻“system.gc”强制启动辣鸡回收机制

