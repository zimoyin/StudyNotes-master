# Java特性

## JAVA8

Java8 新增了非常多的特性，我们主要讨论以下几个：

### **1. Lambda 表达式**

 Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。

> * Lambda 表达式的简单例子:
>
> ```java
> // 1. 不需要参数,返回值为 5  
> () -> 5  
> 
> // 2. 接收一个参数(数字类型),返回其2倍的值  
> x -> 2 * x  
> 
> // 3. 接受2个参数(数字),并返回他们的差值  
> (x, y) -> x – y  
> 
> // 4. 接收2个int型整数,返回他们的和  
> (int x, int y) -> x + y  
> 
> // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  
> (String s) -> System.out.print(s)
> ```
>
> * 示例
>
> ```java
> public class Java8Tester {
>    public static void main(String args[]){
>       Java8Tester tester = new Java8Tester();
>         
>       // 类型声明
>       MathOperation addition = (int a, int b) -> a + b;
>         
>       // 不用类型声明
>       MathOperation subtraction = (a, b) -> a - b;
>         
>       // 大括号中的返回语句
>       MathOperation multiplication = (int a, int b) -> { return a * b; };
>         
>       // 没有大括号及返回语句
>       MathOperation division = (int a, int b) -> a / b;
>         
>       System.out.println("10 + 5 = " + tester.operate(10, 5, addition));
>       System.out.println("10 - 5 = " + tester.operate(10, 5, subtraction));
>       System.out.println("10 x 5 = " + tester.operate(10, 5, multiplication));
>       System.out.println("10 / 5 = " + tester.operate(10, 5, division));
>         
>       // 不用括号
>       GreetingService greetService1 = message ->
>       System.out.println("Hello " + message);
>         
>       // 用括号
>       GreetingService greetService2 = (message) ->
>       System.out.println("Hello " + message);
>         
>       greetService1.sayMessage("Runoob");
>       greetService2.sayMessage("Google");
>    }
>     
>    interface MathOperation {
>       int operation(int a, int b);
>    }
>     
>    interface GreetingService {
>       void sayMessage(String message);
>    }
>     
>    private int operate(int a, int b, MathOperation mathOperation){
>       return mathOperation.operation(a, b);
>    }
> }
> ```
>
> 

### **2. 方法引用** 

方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。

>  方法引用通过方法的名字来指向一个方法。
>
> 方法引用可以使语言的构造更紧凑简洁，减少冗余代码。
>
> 方法引用使用一对冒号 **::** 。
>
> ```java
> //构造器引用：它的语法是Class::new，或者更一般的Class< T >::new实例如下：
> final Car car = Car.create( Car::new );
> final List< Car > cars = Arrays.asList( car );
> 
> //静态方法引用：它的语法是Class::static_method，实例如下：
> cars.forEach( Car::collide );
> 
> //特定类的任意对象的方法引用：它的语法是Class::method实例如下：
> cars.forEach( Car::repair );
> 
> //特定对象的方法引用：它的语法是instance::method实例如下：
> final Car police = Car.create( Car::new );
> cars.forEach( police::follow );
> ```

### 3. 函数式接口

> 函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。
>
> 函数式接口可以被隐式转换为 lambda 表达式。
>
> Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。
>
> * 如定义了一个函数式接口如下：
>
> ```
> @FunctionalInterface
> interface GreetingService 
> {
>     void sayMessage(String message);
> }
> ```
>
> * 那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：
>
> ```
> GreetingService greetService1 = message -> System.out.println("Hello " + message);
> ```

* JDK 1.8 之前已有的函数式接口:

> - java.lang.Runnable
> - java.util.concurrent.Callable
> - java.security.PrivilegedAction
> - java.util.Comparator
> - java.io.FileFilter
> - java.nio.file.PathMatcher
> - java.lang.reflect.InvocationHandler
> - java.beans.PropertyChangeListener
> - java.awt.event.ActionListener
> - javax.swing.event.ChangeListener

* JDK 1.8 新增加的函数接口：
  - java.util.function

> java.util.function 它包含了很多类，用来支持 Java的 函数式编程，该包中的函数式接口有：

| 序号 | 接口                        | 描述                                                         |
| :--- | :-------------------------- | ------------------------------------------------------------ |
| 1    | **BiConsumer<T,U>**         | 代表了一个接受两个输入参数的操作，并且不返回任何结果         |
| 2    | **BiFunction<T,U,R>**       | 代表了一个接受两个输入参数的方法，并且返回一个结果           |
| 3    | **BinaryOperator<T>**       | 代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果 |
| 4    | **BiPredicate<T,U>**        | 代表了一个两个参数的boolean值方法                            |
| 5    | **BooleanSupplier**         | 代表了boolean值结果的提供方                                  |
| 6    | **Consumer<T>**             | 代表了接受一个输入参数并且无返回的操作                       |
| 7    | **DoubleBinaryOperator**    | 代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。 |
| 8    | **DoubleConsumer**          | 代表一个接受double值参数的操作，并且不返回结果。             |
| 9    | **DoubleFunction<R>**       | 代表接受一个double值参数的方法，并且返回结果                 |
| 10   | **DoublePredicate**         | 代表一个拥有double值参数的boolean值方法                      |
| 11   | **DoubleSupplier**          | 代表一个double值结构的提供方                                 |
| 12   | **DoubleToIntFunction**     | 接受一个double类型输入，返回一个int类型结果。                |
| 13   | **DoubleToLongFunction**    | 接受一个double类型输入，返回一个long类型结果                 |
| 14   | **DoubleUnaryOperator**     | 接受一个参数同为类型double,返回值类型也为double 。           |
| 15   | **Function<T,R>**           | 接受一个输入参数，返回一个结果。                             |
| 16   | **IntBinaryOperator**       | 接受两个参数同为类型int,返回值类型也为int 。                 |
| 17   | **IntConsumer**             | 接受一个int类型的输入参数，无返回值 。                       |
| 18   | **IntFunction<R>**          | 接受一个int类型输入参数，返回一个结果 。                     |
| 19   | **IntPredicate**：          | 接受一个int输入参数，返回一个布尔值的结果。                  |
| 20   | **IntSupplier**             | 无参数，返回一个int类型结果。                                |
| 21   | **IntToDoubleFunction**     | 接受一个int类型输入，返回一个double类型结果 。               |
| 22   | **IntToLongFunction**       | 接受一个int类型输入，返回一个long类型结果。                  |
| 23   | **IntUnaryOperator**        | 接受一个参数同为类型int,返回值类型也为int 。                 |
| 24   | **LongBinaryOperator**      | 接受两个参数同为类型long,返回值类型也为long。                |
| 25   | **LongConsumer**            | 接受一个long类型的输入参数，无返回值。                       |
| 26   | **LongFunction<R>**         | 接受一个long类型输入参数，返回一个结果。                     |
| 27   | **LongPredicate**R          | 接受一个long输入参数，返回一个布尔值类型结果。               |
| 28   | **LongSupplier**            | 无参数，返回一个结果long类型的值。                           |
| 29   | **LongToDoubleFunction**    | 接受一个long类型输入，返回一个double类型结果。               |
| 30   | **LongToIntFunction**       | 接受一个long类型输入，返回一个int类型结果。                  |
| 31   | **LongUnaryOperator**       | 接受一个参数同为类型long,返回值类型也为long。                |
| 32   | **ObjDoubleConsumer<T>**    | 接受一个object类型和一个double类型的输入参数，无返回值。     |
| 33   | **ObjIntConsumer<T>**       | 接受一个object类型和一个int类型的输入参数，无返回值。        |
| 34   | **ObjLongConsumer<T>**      | 接受一个object类型和一个long类型的输入参数，无返回值。       |
| 35   | **Predicate<T>**            | 接受一个输入参数，返回一个布尔值结果。                       |
| 36   | **Supplier<T>**             | 无参数，返回一个结果。                                       |
| 37   | **ToDoubleBiFunction<T,U>** | 接受两个输入参数，返回一个double类型结果                     |
| 38   | **ToDoubleFunction<T>**     | 接受一个输入参数，返回一个double类型结果                     |
| 39   | **ToIntBiFunction<T,U>**    | 接受两个输入参数，返回一个int类型结果。                      |
| 40   | **ToIntFunction<T>**        | 接受一个输入参数，返回一个int类型结果。                      |
| 41   | **ToLongBiFunction<T,U>**   | 接受两个输入参数，返回一个long类型结果。                     |
| 42   | **ToLongFunction<T>**       | 接受一个输入参数，返回一个long类型结果。                     |
| 43   | **UnaryOperator<T>**        | 接受一个参数为类型T,返回值类型也为T。                        |

### **4. 默认方法**

 默认方法就是一个在接口里面有了一个实现的方法。*是为了解决接口的修改与现有的实现不兼容的问题。*

> Java 8 新增了接口的默认方法。
>
> 简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。
>
> 我们只需在方法名前面加个 default 关键字即可实现默认方法。

### **5. 新工具**

新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。

### **6. Stream API**

新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。

> Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。
>
> Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。
>
> Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。
>
> 这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。
>
> 元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。

在 Java 8 中, 集合接口有两个方法来生成流：

- **stream()** − 为集合创建串行流。
- **parallelStream()** − 为集合创建并行流。

API:  示例 https://blog.csdn.net/zhouzhenyong/article/details/106738658

> **1. 常用**
>
> forEach   Stream 提供了新的方法 'forEach' 来迭代流中的每个数据。（乱序）
>
> forEachOrdered 顺序迭代流中的每个数据。
>
> **map**  方法用于映射每个元素到对应的结果，对流内元素进行处理得到新的元素，如：List<User>().stream.map(.....getName)  获取用户名称到新流（可以理解为新流）
>
> **flatMap**（对流扁平化处理）: <u>产生一个流</u>，他是通过将mapper应用于当前流中<u>所有元素所产生的结果</u>**连接**到一起而获得（注:这里的每一个结果都是一个流）
>
> > 1. map会将每一条输入映射为一个新对象。{苹果，梨子}.map(去皮） = {去皮苹果，去皮梨子} 其中： “去皮”函数的类型为：A => B
> >
> > 2. flatMap包含两个操作：会将每一个输入对象输入映射为一个新集合，然后把这些新集合连成一个大集合。 {苹果，梨子}.flatMap(切碎) = {苹果碎片1，苹果碎片2，梨子碎片1，梨子碎片2} 其中： “切碎”函数的类型为： A => List<B>
>
> **filter** 方法用于通过设置的条件过滤出元素。
>
> findAny 主要用于过滤后查找某一个数据
>
> findFirst 查找第一个满足的元素。如果`findFirst`选择的元素为`null`，它将抛出`NullPointerException`
>
> limit 方法用于获取指定数量的流。
>
> **sorted** 方法用于对流进行排序。
>
> distinct 数据流的唯一性
>
> toArray  将流转为
>
> > `stream().toArray(String[]::new)`
> >
> > `stream().toArray(数据类型[]::new)`
>
> Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。
>
> > toList()：转换为List集合
> >
> > `stream.collect(Collectors.toList());`
> >
> > toSet() ：转换为Set集合
> >
> > `stream().collect(Collectors.toSet())`
>
> toList 转为 list 
>
> > stream().toList()
>
> 其他：下游收集器、群组和分区
>
> **2. 统计**
>
> takeWhile java9  该函数用于对排序后的数据进行过滤，从头排序，直到不满足条件，这个并不是过滤所有的，跟函数
>
> dropWhile  java9    从Stream中依次删除满足条件的元素，直到不满足条件为止结束删除
>
> max
>
> min
>
> Match
>
> > allMatch   判断条件里的元素，所有的都是，返回true
> >
> > anyMatch  判断的条件里，任意一个元素成功，返回true
> >
> > noneMatch：与allMatch相反，判断条件里的元素，所有的都不是，返回true
> >
> > count  获取当前流内元素个数
> >
> > *注意：这个函数一个Stream只能调用一次，调用一次后，这个Stream就调用close，也就是流就会关闭了*
> >
> > ```java
> > //判断当前路由是存在于集合内
> > boolean isRoute = Routes.stream().anyMatch(absHttpHandler -> absHttpHandler.getRoute().equals(finalPath));
> >  boolean isRoute2 = Routes.stream().filter(absHttpHandler -> absHttpHandler.getRoute().equals(finalPath)).count() > 0;
> > ```
> >
>
> 
>
> **3. 不常用**
>
> * reduce 中间函数，*这个其实是相当于将那些流全部进行汇总之后进行操作* ，常用于并行流
>
> * peek  这个是返回一个新的流，但是并没有对流中的数据进行操作，和map的区别在于map会生成一个新的数据流。 peek和foreach的区别在于peek是中间数据，而forEach是Stream终结流函数
>
> * of 用于为给定元素创建顺序流。我们可以传递单个元素或多个元素。
>
> * ofNullable 用于为给定元素创建顺序流。我们可以传递单个元素或多个元素。(允许放入null)
>
> * iterate 用于生成流数据
>
> * **generate** 用于生成流数据，但是这个函数生成的数据是无限的，因此必须用limit进行限制，该函数主要用于生成自己的流
>
> ```java
> //函数会一直执行，直到limit限制，否则会一直阻塞
>    Stream.generate(()->23).limit(12).forEach(Out::show);
> ```
>
> * **flatMap** 流的扁平化，主要用于将List< List< >> 这种多重嵌套转换为一层，跟CompletableFuture.thenCompose比较像
>
> * empty 返回一个空的集合
>
> * dropWhile  排序后的数据流，这个判断仅判断一次，一旦遇到不满足，则后面的就不再判断，和takeWhile相似
>
> * **skip**(long n);   跳过前几个元素
>
> * **concat**(stream1,stream2) 合并两个流
>
> * builder 让流从开始阶段过渡到构建阶段此时可以通过`accept`、`add`添加元素，当调用 `build`后结束构建阶段
>
> **parallelStream 是流并行处理程序的代替方法。**
>
> > **parallelStream其实就是一个并行执行的流.它通过默认的ForkJoinPool,可能提高你的多线程任务的速度.**
> >
> > Stream具有平行处理能力，处理的过程会分而治之，也就是将一个大任务切分成多个小任务，这表示每个任务都是一个操作，因此像以下的程式片段：
> >
> > ```java
> > List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);
> > numbers.parallelStream()
> >        .forEach(out::println);  
> > ```
> >
> > 你得到的展示顺序不一定会是1、2、3、4、5、6、7、8、9，而可能是任意的顺序，就forEach()这个操作來讲，如果平行处理时，希望最后顺序是按照原来Stream的数据顺序，那可以调用forEachOrdered()。例如：
> >
> > ```java
> > List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);
> > numbers.parallelStream()
> >        .forEachOrdered(out::println);  
> > ```
> >
> > **注意**:如果forEachOrdered()中间有其他如filter()的中介操作，会试着平行化处理，然后最终forEachOrdered()会以原数据顺序处理，因此，使用forEachOrdered()这类的有序处理,可能会（或完全失去）失去平行化的一些优势，实际上中介操作亦有可能如此，例如sorted()方法。
> >
> > **parallelStream背后的男人:ForkJoinPool**
> >
> > ForkJoinPool主要用来使用**分治法(Divide-and-Conquer Algorithm)**来解决问题。
> >
> > **那么使用ThreadPoolExecutor或者ForkJoinPool，会有什么性能的差异呢？**
> > 首先，使用ForkJoinPool能够使用数量有限的线程来完成非常多的具有父子关系的任务，比如使用4个线程来完成超过200万个任务。但是，使用ThreadPoolExecutor时，是不可能完成的，因为ThreadPoolExecutor中的Thread无法选择优先执行子任务，需要完成200万个具有父子关系的任务时，也需要200万个线程，显然这是不可行的。
> > ————————————————
> > 版权声明：本文为CSDN博主「to-two-to」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> > 原文链接：https://blog.csdn.net/u011001723/article/details/52794455

### **7. Date Time API** 

加强对日期与时间的处理。

> java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。
>
> 在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：
>
> - **非线程安全** − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。
> - **设计很差** − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。
> - **时区处理麻烦** − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。
>
> Java 8 在 **java.time** 包下提供了很多新的 API。以下为两个比较重要的 API：
>
> - **Local(本地)** − 简化了日期时间的处理，没有时区的问题。
> - **Zoned(时区)** − 通过制定的时区处理日期时间。
>
> 新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。

### **8. Optional 类**

Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。

> Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。
>
> Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。
>
> Optional 类的引入很好的解决空指针异常。

### **9. Nashorn, JavaScript 引擎**

 Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。

> Nashorn 一个 javascript 引擎。
>
> **Nashorn JavaScript Engine 在 Java 15 已经不可用了。jdk15开始作为一个单独项目维护**

## END

# API 技巧

## 1. Optional - 空指针异常处理

## 2. 泛型擦除

#### 2.1 反射获取泛型

java泛型的类型擦除并不是在class文件中不保存泛型信息，而是在字节码的方法体或者类结构中擦掉了泛型信息，这样做的好处就是在不改变虚拟器的前提下可以引入泛型的特性。通常也是可以获取到泛型

https://blog.csdn.net/qq_33838671/article/details/108695892

https://blog.csdn.net/cpcpcp123/article/details/115141681

https://blog.csdn.net/ShuSheng0007/article/details/89520530

https://cloud.tencent.com/developer/article/1578948

```java
public class Main {
    //
    public void main(String[] args) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        Event<Test> testEvent = new Event<Test>(new Test());
        Event<A> aEvent = new Event<>(new A());

        Class<Main> mainClass = Main.class;
        Method method = mainClass.getMethod("test", Event.class);
        //反射运行方法，参数分别为同样的泛型与其他泛型
        //因为泛型在字节码擦除，所以可以使用其他泛型的上界，这里上界是Object
        method.invoke(mainClass.newInstance(), aEvent);
        method.invoke(mainClass.newInstance(), testEvent);
        //反射出方法的参数类的泛型
        Parameter parameter = method.getParameters()[0];
        System.out.println(parameter.getParameterizedType());
        System.out.println(parameter.getType());
    }

    public void test(Event<Test> event) {
        System.out.println(event);
    }

    static public class Event<T> {
        private final T t;

        public Event(T t) {
            this.t = t;
        }

        public T getT() {
            return t;
        }
    }

    static public class A {
    }

    static public class Test {
        public void test(Event<Main> event) {
        }
    }
}
```



# 工具类

## 1.HttpClient

#### 1. httpClient 工具类

##### 1.1 工具类

```java
/**
 * Description: httpClient工具类
 *
 * @author JourWon
 * @date Created on 2018年4月19日
 */
@Slf4j
public class HttpClientUtils {
    /**
     * 是否需要代理
     */
    @Setter
    @Getter
    private static boolean isProxy = false;


    /**
     * 是否需要PAC来判断域名是否需要代理
     */
    @Getter
    @Setter
    private static boolean isPAC = false;

    // 编码格式。发送编码格式统一用UTF-8
    private static final String ENCODING = "UTF-8";

    // 设置连接超时时间，单位毫秒。
    private static final int CONNECT_TIMEOUT = 15 * 1000;

    // 请求获取数据的超时时间(即响应时间)，单位毫秒。
    private static final int SOCKET_TIMEOUT = 5 * 60 * 1000;

    /**
     * 发送get请求；不带请求头和请求参数
     *
     * @param url 请求地址
     * @return
     * @throws Exception
     */
    public static HttpClientResult doGet(String url) throws IOException {
        return doGet(url, null, null);
    }

    /**
     * 发送get请求；带请求参数
     *
     * @param url    请求地址
     * @param params 请求参数集合
     * @return
     * @throws Exception
     */
    public static HttpClientResult doGet(String url, Map<String, String> params) throws IOException {
        return doGet(url, null, params);
    }

    /**
     * 发送get请求；带请求头和请求参数
     *
     * @param url     请求地址
     * @param headers 请求头集合
     * @param params  请求参数集合
     * @return
     * @throws Exception
     */
    public static HttpClientResult doGet(String url, Map<String, String> headers, Map<String, String> params) throws IOException {
        //构建
        SSLConnectionSocketFactory sslsf = null;
        URI uri = null;
        try {
            //构建SSL
            sslsf = buildSSL();
            //构建URI
            uri = buildURI(url, params);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        // 创建httpClient对象
//        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpClient httpClient = HttpClients.custom().setSSLSocketFactory(sslsf).build();

        HttpHost proxy = getProxy(url);
        log.debug("Get(proxy {}) " + uri, proxy);
        // 创建http对象
        HttpGet httpGet = new HttpGet(uri);
        /**
         * setConnectTimeout：设置连接超时时间，单位毫秒。
         * setConnectionRequestTimeout：设置从connect Manager(连接池)获取Connection
         * 超时时间，单位毫秒。这个属性是新加的属性，因为目前版本是可以共享连接池的。
         * setSocketTimeout：请求获取数据的超时时间(即响应时间)，单位毫秒。 如果访问一个接口，多少时间内无法返回数据，就直接放弃此次调用。
         */
        RequestConfig requestConfig = RequestConfig.custom().setProxy(proxy).setConnectTimeout(CONNECT_TIMEOUT).setSocketTimeout(SOCKET_TIMEOUT).build();
        httpGet.setConfig(requestConfig);

//        httpGet.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36");
        httpGet.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36");
        // 设置请求头
        packageHeader(headers, httpGet);

        // 创建httpResponse对象
        CloseableHttpResponse httpResponse = null;

        // 执行请求并获得响应结果
        return getHttpClientResult(httpResponse, httpClient, httpGet);
    }


    /**
     * 发送post请求；不带请求头和请求参数
     *
     * @param url 请求地址
     * @return
     * @throws Exception
     */
    public static HttpClientResult doPost(String url) throws IOException {
        return doPost(url, null, null, null);
    }

    /**
     * 发送post请求；带请求参数
     *
     * @param url    请求地址
     * @param params 参数集合
     * @return
     * @throws Exception
     */
    public static HttpClientResult doPost(String url, Map<String, String> params) throws IOException {
        return doPost(url, null, params, null);
    }


    /**
     * 发送post请求；带请求参数
     *
     * @param url    请求地址
     * @param params 参数集合
     * @return
     * @throws Exception
     */
    public static HttpClientResult doPost(String url, Map<String, String> headers, Map<String, String> params) throws IOException {
        return doPost(url, headers, params, null);
    }

    /**
     * 发送post请求；带请求头和请求参数
     *
     * @param url     请求地址
     * @param headers 请求头集合
     * @param params  请求参数集合
     * @param body    //文件或字符串等
     *                HttpEntity reqEntity = MultipartEntityBuilder.create().addPart("file", bin).addPart("comment", comment).build();
     *                //字符串 (注意设置请求头)
     *                HttpEntity reqEntity = StringEntity("json/text");
     * @return
     * @throws Exception
     * @body 二进制文件参数，用于上传二进制文件，构建方式<br>
     */
    public static HttpClientResult doPost(String url, Map<String, String> headers, Map<String, String> params, HttpEntity body) throws IOException {

        //构建
        SSLConnectionSocketFactory sslsf = null;
        URI uri = null;
        try {
            //构建SSL
            sslsf = buildSSL();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        // 创建httpClient对象
//        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpClient httpClient = HttpClients.custom().setSSLSocketFactory(sslsf).build();

        HttpHost proxy = getProxy(url);
        log.info("Post(proxy {}) {}", proxy, url);
        // 创建http对象
        HttpPost httpPost = new HttpPost(url);
        /**
         * setConnectTimeout：设置连接超时时间，单位毫秒。
         * setConnectionRequestTimeout：设置从connect Manager(连接池)获取Connection
         * 超时时间，单位毫秒。这个属性是新加的属性，因为目前版本是可以共享连接池的。
         * setSocketTimeout：请求获取数据的超时时间(即响应时间)，单位毫秒。 如果访问一个接口，多少时间内无法返回数据，就直接放弃此次调用。
         */
        RequestConfig requestConfig = RequestConfig.custom().setProxy(proxy).setConnectTimeout(CONNECT_TIMEOUT).setSocketTimeout(SOCKET_TIMEOUT).build();

        httpPost.setConfig(requestConfig);

        // 设置请求头
		/*httpPost.setHeader("Cookie", "");
		httpPost.setHeader("Connection", "keep-alive");
		httpPost.setHeader("Accept", "application/json");
		httpPost.setHeader("Accept-Language", "zh-CN,zh;q=0.9");
		httpPost.setHeader("Accept-Encoding", "gzip, deflate, br");*/
        httpPost.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36");
        packageHeader(headers, httpPost);

        // 封装请求参数
        packageParam(params, httpPost);

        //封装body
        if (body != null) httpPost.setEntity(body);

        // 创建httpResponse对象
        CloseableHttpResponse httpResponse = null;

        // 执行请求并获得响应结果
        return getHttpClientResult(httpResponse, httpClient, httpPost);
    }

    /**
     * 发送put请求；不带请求参数
     *
     * @param url 请求地址
     * @return
     * @throws Exception
     */
    public static HttpClientResult doPut(String url) throws IOException {
        return doPut(url);
    }

    /**
     * 发送put请求；带请求参数
     *
     * @param url    请求地址
     * @param params 参数集合
     * @return
     * @throws Exception
     */
    public static HttpClientResult doPut(String url, Map<String, String> params) throws IOException {
        CloseableHttpClient httpClient = HttpClients.createDefault();
        HttpPut httpPut = new HttpPut(url);
        RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(CONNECT_TIMEOUT).setSocketTimeout(SOCKET_TIMEOUT).build();
        httpPut.setConfig(requestConfig);

        packageParam(params, httpPut);

        CloseableHttpResponse httpResponse = null;

        return getHttpClientResult(httpResponse, httpClient, httpPut);
    }

    /**
     * 发送delete请求；不带请求参数
     *
     * @param url 请求地址
     * @return
     * @throws IOException
     */
    public static HttpClientResult doDelete(String url) throws IOException {
        CloseableHttpClient httpClient = HttpClients.createDefault();
        HttpDelete httpDelete = new HttpDelete(url);
        RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(CONNECT_TIMEOUT).setSocketTimeout(SOCKET_TIMEOUT).build();
        httpDelete.setConfig(requestConfig);

        CloseableHttpResponse httpResponse = null;
        return getHttpClientResult(httpResponse, httpClient, httpDelete);
    }

    /**
     * 发送delete请求；带请求参数
     *
     * @param url    请求地址
     * @param params 参数集合
     * @return
     * @throws IOException
     */
    public static HttpClientResult doDelete(String url, Map<String, String> params) throws IOException {
        if (params == null) {
            params = new HashMap<String, String>();
        }

        params.put("_method", "delete");
        return doPost(url, params);
    }

    /**
     * Description: 封装请求头
     *
     * @param params
     * @param httpMethod
     */
    public static void packageHeader(Map<String, String> params, HttpRequestBase httpMethod) {
        // 封装请求头
        if (params != null) {
            Set<Entry<String, String>> entrySet = params.entrySet();
            for (Entry<String, String> entry : entrySet) {
                // 设置到请求头到HttpRequestBase对象中
                httpMethod.setHeader(entry.getKey(), entry.getValue());
            }
        }
    }

    /**
     * Description: 封装请求参数
     *
     * @param params
     * @param httpMethod
     * @throws UnsupportedEncodingException
     */
    public static void packageParam(Map<String, String> params, HttpEntityEnclosingRequestBase httpMethod) throws UnsupportedEncodingException {
        // 封装请求参数
        if (params != null) {
            List<NameValuePair> nvps = new ArrayList<NameValuePair>();
            Set<Entry<String, String>> entrySet = params.entrySet();
            for (Entry<String, String> entry : entrySet) {
                nvps.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
            }

            // 设置到请求的http对象中
            httpMethod.setEntity(new UrlEncodedFormEntity(nvps, ENCODING));
        }
    }


    /**
     * 设置代理
     */
    private static HttpHost getProxy(String url) {
        ProxyHost proxySource = null;
        if (isProxy) {
            if (isPAC) proxySource = ProxyHostPool.getInstance().getAnyProxyOrThrower(url);
            else proxySource = ProxyHostPool.getInstance().getAny();

            if (proxySource == null) {
                if (isPAC) return null;
                else throw new NullPointerException("没有可用的代理");
            }
            return new HttpHost(proxySource.getHost(), proxySource.getPort(), proxySource.getScheme());
        }
        return null;
    }

    /**
     * 设置代理
     *
     * @return
     */
    private static void addProxy(ProxyHost proxy) {
        ProxyHostPool.getInstance().add(proxy);
    }

    /**
     * Description: 获得响应结果
     *
     * @param httpResponse
     * @param httpClient
     * @param httpMethod
     * @return
     * @throws Exception
     */
    public static HttpClientResult getHttpClientResult(CloseableHttpResponse httpResponse, CloseableHttpClient httpClient, HttpRequestBase httpMethod) throws IOException {
        boolean isRelease = false;
        try {
            // 执行请求
            httpResponse = httpClient.execute(httpMethod);
            InputStream input = null;

            // 获取返回结果
            if (httpResponse != null && httpResponse.getStatusLine() != null) {
                HttpClientResult httpClientResult = new HttpClientResult(httpResponse.getStatusLine().getStatusCode(), httpResponse, httpClient);
                httpClientResult.setURI(httpMethod.getURI());
                return httpClientResult;
            }
            //此时是出错了
            isRelease = true;
            HttpClientResult httpClientResult = new HttpClientResult(HttpStatus.SC_INTERNAL_SERVER_ERROR);
            httpClientResult.setURI(httpMethod.getURI());
            return httpClientResult;
        } finally {
            //释放出错的链接
            if (isRelease) release(httpResponse, httpClient);
        }
    }

    /**
     * Description: 释放资源
     *
     * @param httpResponse
     * @param httpClient
     * @throws IOException
     */
    public static void release(CloseableHttpResponse httpResponse, CloseableHttpClient httpClient) throws IOException {
        // 释放资源
        if (httpResponse != null) {
            httpResponse.close();
        }
        if (httpClient != null) {
            httpClient.close();
        }
    }

    /**
     * get调用接口
     *
     * @param url
     * @return 字符串
     */
    public static String httpGet(String url) throws IOException {
        return httpGet(url, "utf-8");
    }

    /**
     * get调用接口
     *
     * @param url
     * @param charsetName
     * @return 字符串
     */
    public static String httpGet(String url, String charsetName) throws IOException {
        //创建HttpClient实例
        CloseableHttpClient httpClient = HttpClients.createDefault();
        StringBuffer stringBuffer = new StringBuffer();

        InputStream inputStream = null;
        try {
            //创建get方法连接实例，在get方法中传入待连接地址
            HttpGet httpGet = new HttpGet(url);
            //发起请求，并返回请求响应
            HttpResponse httpResponse = httpClient.execute(httpGet);
            //得到响应实体
            HttpEntity entity = httpResponse.getEntity();
            //得到实体中文件
            inputStream = entity.getContent();

            //读取返回内容
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            byte[] b = new byte[6666];
            int code = 0;
            while ((code = inputStream.read(b)) != -1) {
                byteArrayOutputStream.write(b, 0, code);
            }

            return byteArrayOutputStream.toString(charsetName);
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
            httpClient.getConnectionManager().shutdown();
        }
//        return null;  删除可用： throws IOException
    }

    /**
     * 构建SSL
     *
     * @return
     * @throws NoSuchAlgorithmException
     * @throws KeyStoreException
     * @throws KeyManagementException
     */
    private static SSLConnectionSocketFactory buildSSL() throws NoSuchAlgorithmException, KeyStoreException, KeyManagementException {
        //使用 loadTrustMaterial() 方法实现一个信任策略，信任所有证书
        SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() {
            // 信任所有
            public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                return true;
            }
        }).build();
        //NoopHostnameVerifier类:  作为主机名验证工具，实质上关闭了主机名验证，它接受任何
        //有效的SSL会话并匹配到目标主机。
        HostnameVerifier hostnameVerifier = NoopHostnameVerifier.INSTANCE;
        SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslContext, hostnameVerifier);
        return sslsf;
    }

    /**
     * 构建请求地址
     *
     * @throws URISyntaxException
     */
    private static URI buildURI(String url, Map<String, String> params) throws URISyntaxException {
        // 创建访问的地址
        URIBuilder uriBuilder = new URIBuilder(url);
        if (params != null) {
            Set<Entry<String, String>> entrySet = params.entrySet();
            for (Entry<String, String> entry : entrySet) {
                uriBuilder.setParameter(entry.getKey(), entry.getValue());
            }
        }
        URI uri = uriBuilder.build();
        return uri;
    }
}
```



##### 1.2 结果类

```java
package org.example.net.httpclient;


import org.apache.http.Header;
import org.apache.http.HeaderElement;
import org.apache.http.NameValuePair;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.util.EntityUtils;

import java.io.*;
import java.util.function.Consumer;

/**
 * Description: 封装httpClient响应结果
 *
 * @author JourWon
 * @date Created on 2018年4月19日
 */
public class HttpClientResult implements Serializable, AutoCloseable {

    private static final long serialVersionUID = 2168152194164783950L;

    /**
     * 响应状态码
     */
    private int code;
    private java.net.URI URI;

    private boolean isInputStreamClose = false;

    private String content;
    private byte[] contentByte;

    private CloseableHttpClient httpClient;
    private CloseableHttpResponse response;


    public HttpClientResult() {
    }

    public HttpClientResult(int code) {
        this.code = code;
    }

    public HttpClientResult(int code, CloseableHttpResponse response, CloseableHttpClient httpClient) {
        this.response = response;
        this.httpClient = httpClient;
        this.code = code;
    }

    public byte[] getBytes() throws IOException {
        try {
            contentByte = EntityUtils.toByteArray(response.getEntity());
            return contentByte;
        } finally {
            release();
        }
    }

    public int getCode() {
        return code;
    }

    public String getContent() throws IOException {
        try {
            content = EntityUtils.toString(response.getEntity(), "UTF-8");
            return content;
        } finally {
            release();
        }
    }


    public java.net.URI getURI() {
        return URI;
    }

    public void setURI(java.net.URI URI) {
        this.URI = URI;
    }


    /**
     * 获取网络输入流，注意：InputStream.close() 方法无法关闭输入流或者socket，请使用该工具类的release()方法关闭socket等其他资源
     *
     * @return
     * @throws IOException
     */
    public InputStream getInputStream() throws IOException {
        if (isInputStreamClose) return null;
        return response.getEntity().getContent();
    }

    /**
     * 获取，内存输出流，将输入流转为内存输出流
     *
     */
    public ByteArrayOutputStream getByteArrayOutputStream() throws IOException {
        if (isInputStreamClose) return null;
        try (InputStream stream = this.getInputStream()) {
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            byte[] temp = new byte[1024];
            int size;
            while ((size = stream.read(temp)) != -1) {
                outputStream.write(temp, 0, size);
            }
            return outputStream;
        }finally {
            release();
        }
    }

    /**
     * 将输入流转接到输出流，并输出
     */
    public void inputStreamToOutSteam(OutputStream outStream) throws IOException {
        if (isInputStreamClose) return;
        try (InputStream stream = this.getInputStream()) {
            byte[] temp = new byte[65535/2];
            int size;
            while ((size = stream.read(temp)) != -1) {
                outStream.write(temp,0,size);
            }
        }finally {
            release();
        }
    }

    /**
     * 获取response header中Content-Disposition中的filename值
     *
     */
    public String getFileName() {
        Header contentHeader = response.getFirstHeader("Content-Disposition");
        String filename = null;
        if (contentHeader != null) {
            HeaderElement[] values = contentHeader.getElements();
            if (values.length == 1) {
                NameValuePair param = values[0].getParameterByName("filename");
                if (param != null) {
                    //filename = new String(param.getValue().toString().getBytes(), "utf-8");
                    //filename=URLDecoder.decode(param.getValue(),"utf-8");
                    filename = param.getValue();
                }
            }
        }
        return filename;
    }

    public CloseableHttpResponse getResponse() {
        return response;
    }



    /**
     * Description: 释放资源
     *
     * @throws IOException
     */
    public void release() throws IOException {
        // 释放资源
        HttpClientUtils.release(response, httpClient);
        isInputStreamClose = true;
    }

    /**
     * EventSource 是服务器推送的一个网络事件接口。一个 EventSource 实例会对 HTTP 服务开启一个持久化的连接，以text/event-stream 格式发送事件，会一直保持开启直到被要求关闭。
     *
     * @param source
     * @link <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource">文档</a>
     */
    public void eventSource(Consumer<String> source) throws IOException {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(this.getInputStream()))) {
            String line = null;
            while ((line = reader.readLine()) != null) {
                source.accept(line);
            }
        } finally {
            release();
        }

    }

    @Override
    public void close() throws IOException {
        release();
    }
}

```

##### 2. 使用工具类特殊状况

* 使用POST请求，发送 JSON，请要求返回数据的编码格式

```java
//构建参数体
StringEntity stringEntity = new StringEntity(copyConfig.toJson().toString(), StandardCharsets.UTF_8);
stringEntity.setContentType("application/json;charset=utf-8");
stringEntity.setContentEncoding("UTF-8");
//        System.exit(0);
//响应
HttpClientResult httpClientResult = HttpClientUtils.doPost(URL, buildHeaders(), null, stringEntity);
```

* 使用 EventSource

```java
httpClientResult.eventSource(System.out::println);
```

##### 1.3 代理类

```java
@Getter
@ToString
public class ProxyHost {
    private String host;
    private int port;
    @Setter
    private String scheme;
    /**
     * 上次计算延迟的值，当ping 小于 0 时，表示主机不可用
     */
    private long ping = 9999;
    /**
     * 添加该代理的时间
     */
    private long addTime;
    /**
     * 主机所在的物理位置
     */
    @Setter
    private String hostLocation;

    public ProxyHost(String host, int port) {
        setHost(host);
        setPort(port);
        update();
    }

    public ProxyHost(String host, int port, String scheme) {
        setHost(host);
        setPort(port);
        this.scheme = scheme;
        update();
    }

    public ProxyHost(String host, int port, String scheme, long addTime, String hostLocation) {
        setHost(host);
        setPort(port);
        this.scheme = scheme;
        this.addTime = addTime;
        this.hostLocation = hostLocation;
        update();
    }

    public ProxyHost(String host, int port, String scheme, long addTime) {
        setHost(host);
        setPort(port);
        this.scheme = scheme;
        this.addTime = addTime;
        update();
    }

    public ProxyHost(String host, int port, long addTime) {
        setHost(host);
        setPort(port);
        this.addTime = addTime;
        update();
    }

    public ProxyHost(String host, int port, String scheme, String hostLocation) {
        setHost(host);
        setPort(port);
        this.scheme = scheme;
        this.hostLocation = hostLocation;
        update();
    }

    private void setPort(int port) {
        if (port <= 0 || port >= 65536) {
            throw new IllegalArgumentException("port must be between 0 and 65536");
        }
        this.port = port;
    }

    private void setHost(String host) {
        this.host = host;
    }


    public InetAddress getHostAddress(){
        return new InetSocketAddress("", 0).getAddress();
    }
    /**
     * 刷新ping 与 添加时间
     */
    public void update() {
        // TODO Auto-generated method stub
        this.addTime = System.currentTimeMillis();
        try {
            // 创建Socket对象并连接到指定的IP地址和端口号
            Socket socket = new Socket();
            long start = System.currentTimeMillis();
            socket.connect(new InetSocketAddress(this.host, this.port), 5*1000); // 5000为连接超时时间（毫秒）

            // 如果连接成功，则主机存活
            ping = (System.currentTimeMillis() - start);

            // 关闭套接字
            socket.close();
        } catch (Exception e) {
            // 如果发生异常，则主机不可达或连接超时
            ping = -1;
        }
    }
}

```



##### 1.4 代理池

```java
public class ProxyHostPool extends ArrayList<ProxyHost> {
    private volatile static ProxyHostPool INSTANCE;
    @Getter
    private static final ProxyFilterFile filter = ProxyFilterFile.getInstance("ProxyHostPool");

    /**
     * 添加默认的代理服务器
     */
    private ProxyHostPool() {
        add("127.0.0.1", 8070);
        add("127.0.0.1", 7890);
        add("127.0.0.1", 7090);
    }

    public static ProxyHostPool getInstance() {
        if (INSTANCE == null) synchronized (ProxyHostPool.class) {
            if (INSTANCE == null) INSTANCE = new ProxyHostPool();
        }
        return INSTANCE;
    }

    /**
     * 添加代理服务器
     *
     * @param proxyHost element whose presence in this collection is to be ensured
     * @return
     */
    @Override
    public boolean add(ProxyHost proxyHost) {
        return super.add(proxyHost);
    }

    /**
     * 添加代理服务器
     */
    public boolean add(String hostName, int port) {
        return super.add(new ProxyHost(hostName, port));
    }

    /**
     * 添加代理服务器
     */
    public boolean add(String hostName, int port, String scheme) {
        return super.add(new ProxyHost(hostName, port, scheme));
    }

    /**
     * 添加代理服务器
     */
    public boolean add(String hostName, int port, String scheme, String location) {
        return super.add(new ProxyHost(hostName, port, scheme, location));
    }

    /**
     * 映射所有的代理服务器
     *
     * @param function
     * @return
     */
    public List<Object> map(Function<ProxyHost, Object> function) {
        return this.stream().map(function).collect(Collectors.toList());
    }

    /**
     * 返回任一可用的代理服务器，如果没有则返回Null
     */
    public ProxyHost getAny() {
        for (ProxyHost proxyHost : this) {
            if (proxyHost.getPing() > 0) return proxyHost;
        }
        return null;
    }

    /**
     * 返回任一可用的代理服务器，如果没有则返回Null
     */
    public InetAddress getAnyOfInetAddress() {
        for (ProxyHost proxyHost : this) {
            if (proxyHost.getPing() >= 0) return proxyHost.getHostAddress();
        }
        return null;
    }

    /**
     * 判断此URL是否需要代理，如果需要返回代理，否则返回Null
     * 注意 如果URL需要代理，但是没有可用的代理服务器就抛出异常
     */
    public ProxyHost getAnyProxyOrNull(String url) {
        if (filter.isProxy(url)) {
            ProxyHost any = getAny();
            if (any == null) throw new NullPointerException("没有可用的代理");
            return any;
        } else {
            return null;
        }

    }
}

```



##### 1.5 PAC

```java

/**
 * 代理过滤文件（PAC）
 * 该实现是依靠主机地址与IP地址进行判断，如果有任一一项不符合就与结果产生偏差。哪怕是域名相同，ip不同
 */
@Getter
public class ProxyFilterFile {
    /**
     * 代理域名
     */
    private final HashSet<InetAddress> PROXY_HOST = new HashSet<>();
    /**
     * 直连域名
     */
    private final HashSet<InetAddress> PROXY_DIRECT = new HashSet<>();
    /**
     * 设置为 Ture 后，如果要访问的域没有在代理列表与直接访问列表中，那此域就走代理，反之亦然
     * 默认为 false 如果没有任何匹配的域名则直连该域名
     */
    @Setter
    private volatile boolean isProxyHostList = false;
    /**
     * 是否开启动态添加域名，开启后可以针对子域名进行是否代理判断，但是开启后需要消耗额外的性能开销
     */
    @Setter
    private volatile boolean isDynamicAddition = false;
    /**
     * 过滤器名称
     */
    private final String name;

    private static final HashMap<String, ProxyFilterFile> Instances = new HashMap<String, ProxyFilterFile>();

    private ProxyFilterFile(String name) {
        this.name = name;
        Instances.put(name, this);
    }

    /**
     * 获取一个过滤器配置实例
     *
     * @param name 实例名称
     */
    public static ProxyFilterFile getInstance(String name) {
        return Instances.getOrDefault(name, new ProxyFilterFile(name));
    }

    /**
     * 是否代理该域名
     * 该实现是依靠主机地址与IP地址进行判断，如果有任一一项不符合就与结果产生偏差。哪怕是域名相同，ip不同
     *
     * @return 是否代理该域名
     */
    public boolean isProxy(String address0) {
        InetAddress address = parse(address0);
        boolean containsProxy = PROXY_HOST.contains(address);
        boolean containsDirect = PROXY_DIRECT.contains(address);
        //如果该域名不再代理列表与直连列表，则动态添加该域名到其中一个列表中
        if (!containsDirect && !containsProxy && isDynamicAddition && address != null) return dynamicAddition(address);
        if (containsProxy) return true;
        if (containsDirect) return false;
        return isProxyHostList;
    }

    /**
     * 动态添加域名
     * @return  是否需要代理当前的域名
     */
    private boolean dynamicAddition(InetAddress address) {
        String addressHostName = address.getHostName();
        boolean isProxy = PROXY_HOST.stream().anyMatch(inetAddress -> inetAddress.getHostName().contains(addressHostName) || addressHostName.contains(inetAddress.getHostName()));
        boolean isDirect = PROXY_DIRECT.stream().anyMatch(inetAddress -> inetAddress.getHostName().contains(addressHostName) || addressHostName.contains(inetAddress.getHostName()));

        if (isProxy) addProxyHostList(addressHostName);
        if (isDirect) addDirectList(addressHostName);
        if (!isProxy && !isDirect) addDirectList(addressHostName);
        return isProxy;
    }

    /**
     * 更新代理列表
     */
    public void updateProxyHostList(String... addresses) {
        PROXY_HOST.clear();
        addProxyHostList(addresses);
    }

    /**
     * 更新直连列表
     */
    public void updateProxyDirectList(String... addresses) {
        PROXY_DIRECT.clear();
        addDirectList(addresses);
    }


    /**
     * add代理列表
     */
    public void addProxyHostList(String... addresses) {
        for (String address : addresses) {
            PROXY_HOST.add(parse(address));
        }
    }


    /**
     * add直连列表
     */
    public void addDirectList(String... addresses) {
        for (String address : addresses) {
            PROXY_DIRECT.add(parse(address));
        }
    }

    /**
     * remove代理列表
     */
    public void removeProxyHostList(String... addresses) {
        for (String address : addresses) {
            PROXY_HOST.remove(parse(address));
        }
    }

    /**
     * remove直连列表
     */
    public void removeDirectList(String... addresses) {
        for (String address : addresses) {
            PROXY_DIRECT.remove(parse(address));
        }
    }

    /**
     * 将列表解析出主机实例列表
     *
     * @param hosts 域名/ip/url 列表
     */
    public static List<InetAddress> parseHosts(String[] hosts) {
        List<InetAddress> addresses = new ArrayList<InetAddress>();
        for (String host : hosts) {
            addresses.add(parse(host));
        }
        return addresses;
    }

    /**
     * 将地址解析出主机实例列表
     *
     * @param host0 域名/ip/url
     */
    public static InetAddress parse(String host0) {
        Pattern pattern = Pattern.compile("(?:(?:https?|http|[a-z]*)://)?([\\w.-]+)(?::\\d+)?(?:/.*)?");
//        Pattern pattern = Pattern.compile("(?i)(?:(?:https?|tcp|udp|file|jar)://)?([a-z0-9.-]+)(?::\\\\d+)?");
        Matcher matcher = pattern.matcher(host0);
        if (matcher.find()) {
            String hostGroup = matcher.group(1);
            try {
                return InetAddress.getByName(hostGroup);
            } catch (UnknownHostException e) {
                throw new RuntimeException("无法解析该地址: " + host0, e);
            }
        }
        return null;
    }
}

```



### 3. 代理池管理类

```java
public class ProxyHostPool extends ArrayList<ProxyHost> {
    private volatile static ProxyHostPool INSTANCE;

    private ProxyHostPool() {
        add("127.0.0.1",8070);
    }

    public static ProxyHostPool getInstance() {
        if (INSTANCE == null) synchronized (ProxyHostPool.class) {
            if (INSTANCE == null) INSTANCE = new ProxyHostPool();
        }
        return INSTANCE;
    }

    @Override
    public boolean add(ProxyHost proxyHost) {
        return super.add(proxyHost);
    }

    public boolean add(String hostName, int port) {
        return super.add(new ProxyHost(hostName, port));
    }

    public boolean add(String hostName, int port, String scheme) {
        return super.add(new ProxyHost(hostName, port, scheme));
    }

    public boolean add(String hostName, int port, String scheme,String location) {
        return super.add(new ProxyHost(hostName, port, scheme,location));
    }

    public List<Object> map(Function<ProxyHost, Object> function) {
        return this.stream().map(function).collect(Collectors.toList());
    }

    public ProxyHost getAny() {
        for (ProxyHost proxyHost : this) {
            if (proxyHost.getPing() > 0) return proxyHost;
        }
        return null;
    }

    public InetAddress getAnyOfInetAddress() {
        for (ProxyHost proxyHost : this) {
            if (proxyHost.getPing() > 0) return proxyHost.getHostAddress();
        }
        return null;
    }
}

```

```java
@Getter
@ToString
public class ProxyHost {
    private String host;
    private int port;
    @Setter
    private String scheme;
    /**
     * 上次计算延迟的值，当ping 小于 0 时，表示主机不可用
     */
    private long ping = 9999;
    /**
     * 添加该代理的时间
     */
    private long addTime;
    /**
     * 主机所在的物理位置
     */
    @Setter
    private String hostLocation;

    public ProxyHost(String host, int port) {
        setHost(host);
        setPort(port);
        update();
    }

    public ProxyHost(String host, int port, String scheme) {
        setHost(host);
        setPort(port);
        this.scheme = scheme;
        update();
    }

    public ProxyHost(String host, int port, String scheme, long addTime, String hostLocation) {
        setHost(host);
        setPort(port);
        this.scheme = scheme;
        this.addTime = addTime;
        this.hostLocation = hostLocation;
        update();
    }

    public ProxyHost(String host, int port, String scheme, long addTime) {
        setHost(host);
        setPort(port);
        this.scheme = scheme;
        this.addTime = addTime;
        update();
    }

    public ProxyHost(String host, int port, long addTime) {
        setHost(host);
        setPort(port);
        this.addTime = addTime;
        update();
    }

    public ProxyHost(String host, int port, String scheme, String hostLocation) {
        setHost(host);
        setPort(port);
        this.scheme = scheme;
        this.hostLocation = hostLocation;
        update();
    }

    private void setPort(int port) {
        if (port <= 0 || port >= 65536) {
            throw new IllegalArgumentException("port must be between 0 and 65536");
        }
        this.port = port;
    }

    private void setHost(String host) {
        this.host = host;
    }


    public InetAddress getHostAddress(){
        return new InetSocketAddress("", 0).getAddress();
    }
    /**
     * 刷新ping 与 添加时间
     */
    public void update() {
        // TODO Auto-generated method stub
        this.addTime = System.currentTimeMillis();
        try {
            // 创建Socket对象并连接到指定的IP地址和端口号
            Socket socket = new Socket();
            long start = System.currentTimeMillis();
            socket.connect(new InetSocketAddress(this.host, this.port), 5*1000); // 5000为连接超时时间（毫秒）

            // 如果连接成功，则主机存活
            ping = (System.currentTimeMillis() - start);

            // 关闭套接字
            socket.close();
        } catch (Exception e) {
            // 如果发生异常，则主机不可达或连接超时
            ping = -1;
        }
    }
}

```



## 2.JSON Path

## 3.线程池

```java
package github.zimoyin.mtool.uilt;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.management.ManagementFactory;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;


public class NewThreadPoolUtils {
    /**
     *
     *     刚开始都是在创建新的线程，达到核心线程数量5个后，新的任务进来后不再创建新的线程，
     *     而是将任务加入工作队列，任务队列到达上线5个后，新的任务又会创建新的普通线程，
     *     直到达到线程池最大的线程数量10个，后面的任务则根据配置的饱和策略来处理。
     *
     *
     * @Title ThreadPoolExecutor:创建自定义线程池，
     * @param 池中常驻的线程数为 1
     * @param 允许最大的线程数为  cpu核心数*2 + 所有的插件数，
     * @param 存活时间450ms,
     * @param 单位毫秒,
     * @param 双缓冲队列 最大的线程数*2，,
     * @param 拒绝策略CallerRunsPolicy 如果队列满了，就拿主线程执行
     */
    private static ThreadPoolExecutor tpe = null;
    protected Logger logger = LoggerFactory.getLogger(NewThreadPoolUtils.class);

    private int AllBotGroups = 0; //所有机器人加的群数
    private int cpuCount;//cpu 核数

    private final int MinThreadCount = 10;//最小线程
    private int MaxThreadCount = 120;//最大线程
    private int QueueCount = MinThreadCount/2+1;//队列数

    private static NewThreadPoolUtils obj = null;

    //单例
    private NewThreadPoolUtils() {
        //AllBotGroups = Login.getBots().stream().map(Bot::getBot).map(Bot::getGroups).collect(Collectors.toList()).stream().map(ContactList::size).reduce(0, Integer::sum);
        cpuCount = ManagementFactory.getOperatingSystemMXBean().getAvailableProcessors();
//        MaxThreadCount = cpuCount * 2 + new File("./plug").list().length;
//        QueueCount = MaxThreadCount * 2;

        tpe = new ThreadPoolExecutor(MinThreadCount, MaxThreadCount,
                450,
                TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(QueueCount),
                new MyTheadFactory("ThreadPool"),
                new ThreadPoolExecutor.CallerRunsPolicy());

        logger.debug("线程池创建成功,最大线程数: "+MaxThreadCount);
    }

    public static NewThreadPoolUtils getInstance() {
        if (obj == null) {
            synchronized (NewThreadPoolUtils.class) {
                obj = new NewThreadPoolUtils();
            }
        }
        return obj;
    }

    public ThreadPoolExecutor getTpe() {
        return tpe;
    }

    public void execute(Runnable runnable) {
        tpe.execute(runnable);
    }


    static class MyTheadFactory implements ThreadFactory {
        private static final AtomicInteger poolNumber = new AtomicInteger(1);
        private final ThreadGroup group;
        private final AtomicInteger threadNumber = new AtomicInteger(1);
        private final String namePrefix;

        MyTheadFactory() {
            //默认namePrefix = default-name-pool
            this("default-name-pool");
        }

        MyTheadFactory(String name) {
            SecurityManager s = System.getSecurityManager();
            group = (s != null) ? s.getThreadGroup() :
                    Thread.currentThread().getThreadGroup();
            //此时namePrefix就是 name + 第几个用这个工厂创建线程池的
            this.namePrefix = name +"-p"+
                    poolNumber.getAndIncrement();
        }

        public Thread newThread(Runnable r) {
            //此时线程的名字 就是 namePrefix + -thread- + 这个线程池中第几个执行的线程
            Thread t = new Thread(group, r,
                    namePrefix + "-Thread-" + threadNumber.getAndIncrement(),
                    0);
            if (t.isDaemon())
                t.setDaemon(false);
            if (t.getPriority() != Thread.NORM_PRIORITY)
                t.setPriority(Thread.NORM_PRIORITY);
            return t;
        }
    }
}

```





# jlink

**jlink** 是一个 Java11 后被添加的命令行工具，用于创建可执行的 Java 运行时 (**jre**)



# 如何向控制台监听输入内容

```
//不间断的读取 System.`in` 的内容
//不间断的读取 anyInput 的内容
//将上面两个流的内容进行合并
//将合并后的流给系统。注意：合并后的流应该是你自己继承的一个输出流
```

# 如何过滤控制台信息

```kotlin
package github.zimoyin.github.zimoyin.logger

import java.io.PrintStream
import java.util.function.Consumer


/**
 * 控制台日志过滤器
 */
object ConsoleOutFilter : PrintStream(System.out) {
    private val outFilters: ArrayList<Consumer<StringBuf>> = ArrayList()


    /**
     * 添加过滤器，注意该过滤器是按照缓存数进行处理的，在输出前可能会被执行多次，由程序将一段话进行分割，之后进行执行
     */
    fun addOutFilter(consumer: Consumer<StringBuf>) {
        outFilters.add(consumer)
    }

    init {
        System.setOut(this)
    }

    override fun write(buf: ByteArray, off: Int, len: Int) {
        // 将 buf 数组中的字节转换成字符串
        var str = String(buf, off, len)

        //执行过滤器，过滤器为串行执行，当某一个过滤器执行完成后由下一个过滤器接着执行
        val stringBuf = StringBuf(str, true)
        outFilters.forEach {
            it.accept(stringBuf)
        }
        //如果不输出结果则直接返回
        if (!stringBuf.stdOut) return

        // 将过滤后的字符串转换回字节数组，并输出到流中
        val newBuf = stringBuf.string.toByteArray()
        super.write(newBuf, 0, newBuf.size)
    }


    data class StringBuf(
        var string: String,
        var stdOut: Boolean = true,
    )
}
```



# 绕过系统控制台输出流，直接向控制台输出

```java
    val fos = FileOutputStream(FileDescriptor.out) // 获取控制台输出流
    val ps = PrintStream(fos) // 将输出流传递给PrintStream的构造函数
    System.setOut(ps);
    ps.println("Hello World!")
    println("Hello World!")
    //用此方法后就无法过滤该输出
```



# IDEA Debug

### 小方法

- **评估表达式**
  - 表达式模式、代码模式。可以支持动态查看，以及代码段调试。
  - 通常用于调用调试中的方法查看返回值等
- **丢弃当前帧**
  - 有时候我们用IDEA进行debug，跑进来了，debug到某个[断点](https://so.csdn.net/so/search?q=断点&spm=1001.2101.3001.7020)或某一行，如果此时我们不想继续走下去的时候使用
  - 允许你回到上一个调用方法的站点处，并允许你重新执行该方法。如果不使用该技巧那么就只有重新DEBUG才能达到
  - 注意虽然可以重置帧，但是该方法运行的代码却实实在在的产生了影响，如果对全局对象或者变量进行操作了的话
- **强制返回**
  - 强制返回后在当前行后的代码将不会执行
  - *强制返回 | 避免操作资源*
- 即时修改调试数据（选中变量按F2）
- 抛出异常
- 单步跳出代码块： 这个功能允许你在调试时，一步一步地跳出当前的代码块，直到返回到上一级的代码块。
- 强制步入： 这个功能会强制进入你选中的方法或函数，即使这个方法或函数没有设置断点。
- **强制步过**：这个功能会强制跳过你选中的方法或函数，即使这个方法或函数设置了断点。
- 智能步入： 这个功能会智能地选择一个最可能的方法或函数进行步入。
- 线程转储： 这个功能会获取当前所有线程的信息，包括线程的状态、调用堆栈等。
- 追踪当前流链：这个功能会追踪当前线程的执行路径，并显示出来。
- **运行到光标处**：这个功能会让程序运行到你在代码中设置的光标处。
- **强制运行到光标处**：这个功能会强制让程序运行到你在代码中设置的光标处，即使光标处的代码没有设置断点。
- 显示执行点：这个功能会在代码中高亮显示当前正在执行的代码行。并将你的光标跳转到执行处
- 最新版IDEA可以对 Lambda 表达式进行打断点了
- 对表达式添加监视：让该表达式的值在变量列表中展示，该功能位于变量表上方
- 对表达式求值：该功能位于变量表上方

![image-20240502213106809](%E6%8A%80%E5%B7%A7.assets/image-20240502213106809.png)

> 断点条件与过滤器

![图片](%E6%8A%80%E5%B7%A7.assets/640.webp)



![图片](%E6%8A%80%E5%B7%A7.assets/640.webp)



### 字段断点（反射无效）

- 当读写字段时，字段断点会命中。通过反射读写不会命中
![图片](%E6%8A%80%E5%B7%A7.assets/640.webp)

- 



### 异常断点（排除框架异常）

- 捕获空指针异常，同时排除spring框架中的空指针异常。用于在排除代码时不知道具体异常位置，可通过异常断点定位。

![图片](%E6%8A%80%E5%B7%A7.assets/640.webp)



### 条件断点（源码中执行自定义代码）

- 指定时间内连接zk超时，使用【条件断点+评估功能】重连，避免报错无法启动。

![图片](%E6%8A%80%E5%B7%A7.assets/640.webp)

### 过滤器

- 实例过滤器

- - 当前this的id等于指定id才命中

- 类过滤器

- - 当前`this.getClass()`等于指定Class 【子类不行】

- 合格次数

- - 命中指定次数才生效

![图片](%E6%8A%80%E5%B7%A7.assets/640.webp)



# 库收集

## 1. 音视频

* jave: 提供了对FFmpeg的封装，但它主要专注于音频和视频编解码以及处理，对于其他FFmpeg功能的封装可能相对较少。
* javacv: JavaCV是一个更全面的库，不仅提供了对FFmpeg的封装，还封装了其他计算机视觉相关的库和工具，例如OpenCV。这使得JavaCV成为一个功能强大且全面的音视频处理库，特别适用于需要结合计算机视觉和音视频处理的应用场景。

### 2. ORM框架(数据库框架)

* MyBatis
* MyBatis-plus
* MyBatis-flex: 功能点多的框架 https://mybatis-flex.com/zh/intro/comparison.html
* easy-query: 一款兼具`dsl`的操控性和`object relation query`的便捷性，同时具备两者的orm。借鉴于 Net 的 EF 框架
  * 联级筛选 Include Filter
  * 数据库列加密
  * 数据追踪
  * 大数据流式查询返回
* **[Exposed](https://github.com/JetBrains/Exposed)**: Kotlin SQL Framework
  * 使用 Exposed，您有两种数据库访问选项：包装 DSL 和轻量级 DAO
  * 只需很少的更改或无需更改即可在各种数据库引擎之间进行切换。
  * **Exposed** 的设计理念允许开发者以非常接近SQL的方式编写代码，这意味着它在处理复杂SQL方面有天然的优势
  * 不具备 easy-query 列出的功能，其余具备
  * SQL DLS
* **[ktorm](https://github.com/kotlin-orm/ktorm)**： 适用于 Kotlin 的轻量级 ORM 框架，具有强类型 SQL DSL 和序列 API。
  * 不具备 easy-query 列出的功能，其余具备

### 3. 数据库与工具

* [questdb](https://github.com/questdb/questdb): 用于快速摄取和 SQL 查询的开源时间序列数据库
* **[Jailer](https://github.com/Wisser/Jailer)**： 数据库子集和关系数据浏览工具。

# END